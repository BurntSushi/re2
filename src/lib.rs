#![crate_id = "regexp#0.1.0"]
#![crate_type = "rlib"]
#![crate_type = "dylib"]
#![license = "UNLICENSE"]
#![doc(html_root_url = "http://burntsushi.net/rustdoc/regexp")]

//! Regular expressions for Rust.

#![feature(macro_rules, phase)]

extern crate collections;
#[phase(syntax, link)]
extern crate log;
extern crate rand;

#[cfg(bench)]
extern crate stdtest = "test";

// During tests, this links with the `regexp` and `regexp_re` crates to provide
// the `re!` macro (so it can be tested).
// We don't do this for benchmarks since it (currently) prevents compiling
// with -Z lto.
#[cfg(test, not(bench))]
#[phase(syntax)]
extern crate regexp_re;
#[cfg(test, not(bench))]
extern crate regexp;

pub use parse::Error;
pub use re::{Regexp, Captures, SubCaptures, SubCapturesPos};
pub use re::{FindCaptures, FindMatches};
pub use re::{Replacer, NoExpand, RegexpSplits, RegexpSplitsN};
pub use re::{quote, is_match, regexp};

mod compile;
mod parse;
mod re;
mod vm;

#[cfg(test)]
mod test;

/// The `program` module exists to support the `re!` macro. Do not use.
#[doc(hidden)]
pub mod program {
    // Exporting this stuff is bad form, but it's necessary for two reasons.
    // Firstly, the `re!` syntax extension is in a different crate and requires
    // access to the representation of a regexp (particularly the instruction
    // set) in order to generate an AST. This could be mitigated if `re!` was
    // defined in the same crate, but this has undesirable consequences (such
    // as requiring dynamic linking to `libsyntax`).
    // Secondly, the AST generated by `re!` must *also* be able to access the
    // representation of a regexp program so that it may be constructed
    // staticly. Yes, this means a user program will actually construct a
    // program using actual instructions, but it's all hidden behind the `re!`
    // macro. This, AFAIK, is impossible to mitigate.
    //
    // For similar reasons, the representation of `Regexp` is also exported
    // but is hidden in the public API documentation.
    //
    // On the bright side, `rustdoc` lets us hide this from the public API
    // documentation, which is an acceptable compromise.
    pub use super::parse::Flags;
    pub use super::compile::{
        Program, MaybeStatic,
        Inst, OneChar, CharClass, Any, Save, Jump, Split,
        Match, EmptyBegin, EmptyEnd, EmptyWordBoundary,
        Dynamic, Static,
    };
}
